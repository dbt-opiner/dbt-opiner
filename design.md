# dbt opiner tool

## Why?

In a data mesh architecture each domain implements their data products in a self-serve independent way. However there's a need for a Federated Computational Governance that ensures compliance and standardization across domains while allowing for domain-specific flexibility.

dbt is a wide-use tool for ELT (Extract, Load, Transform) processes that can be used to implement data products in a data mesh architecture. dbt is very flexible (not opinionated) which makes it good for any type of organization and data modelling technique, but this opens the door to a lack of standardization and compliance across multiple projects.

Some tools already exist to tackle some of these aspects, for example:
- Linters and formaters for sql code ([SQLFluff](https://github.com/sqlfluff/sqlfluff/), [sqlftm](https://github.com/tconbeer/sqlfmt))
- Wide variety of checks for dbt projects: [dbt-checkpoint](https://github.com/dbt-checkpoint/dbt-checkpoint)
- Metadata linting: [dbt-score](https://dbt-score.picnic.tech/)
- PR review tool: [recce](https://github.com/datarecce/recce)

These tools are not integrated and require manual work to set up. Moreover, the opinions or rules about how a dbt project should be are implicit and often not easily configurable.

## What
This project aims to provide a unified tool that integrates all these features and provides an easy way to configure and define new opinions. The tool should be able to:
- Lint SQL and YAML files
- Check dbt projects for best practices.
  - Best practices are defined with default opinions that can be enabled or disabled.
  - Opinions can be defined by the user in a custom folder (that can be fetched from a git repository)
  - Opinions have different severity: enforced, recommended, optional
  - Best practices include:
    - Naming conventions
    - Data and unit tests checks
    - Documentation checks
    - Dependency checks
    - Performance checks
    - Security/Privacy checks
    - etc.
- Generates a report with the results of the checks and suggestions for improvement in PR CI steps.
- Fix or suggest fixes for some of the issues found in the checks.

## How

### Brainstorming

Following sqlfluff architecture we will have:
- A parser/project instantiatior that reads the dbt project and creates a project object that can be linted. This object will contain all the information about the project and the files in it. Keep in mind that a project has also an internal structure with different nodes. The main entry point for the project instatiator will be the manifest and catalog json files that need to be generated by dbt before running the tool. The dbt manifest clasess are not so cool, so probably we won't use them.

- Opinions (rules) following a factory pattern. Opinion configuration should be defined in a yaml file or in the toml file of the dbt project. Opinions can be enabled or disabled and have different severity levels. Opinions can be defined in a custom folder that can be fetched from a git repository. The custom opinions must be .py files that inherit from the base opinion class. Find a way to add and be able to test those in an elegant way.

Borrowing from Recce we will have:
- A diff between the current branch and the target branch to check for changes in the dbt project. Similar to Terraform plans, the output of the diff will show what will be added, changed, or removed in the dbt project.

- For this some functionalities to deal with git and github will be needed.

Borrowing from dbt-score:
- Gamify the experience with badges and scores for the project and models.

Borrowing from dbt-checkpoint:
- The ability to run checks as pre-commit hooks.
- Also, check how they deal with doing dbt-parse so we don't have the issue that dv-checkpoint has (can't run as pre-commit hook).

Original stuff:

- A documentation generator that describe what opinions are recommended in the project.
- Use a local LLM (probably [this one](https://huggingface.co/meta-llama/Meta-Llama-3-8B-Instruct) or maybe [this one](https://huggingface.co/docs/transformers/v4.42.0/model_doc/mistral)) to check for certain things like "is this a PII column?" or "is this description good enough? and contains all the required key parts?", and maybe some other wild things we can think of.
- Generate what models would need to be full-refreshed if a certain model is changed.


### Manifest loading
Each changed file belongs to a project. We need to find for each file the project in case multi-project repos, and generate the manifests for all projects.

Map files to check (as objects) with manifest of the project it belong (as objects).
Get all files changed or all files in the project. Create an object with the project manifest and the file paths.
DbtProject contains a list of Files (SQL, YAML, etc.) and a Manifest object.


## Developing and testing
Create two dbt projects that can use duckDB to develop locally without any connection to external DBs.
